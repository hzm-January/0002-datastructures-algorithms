# 字符串匹配
## BF算法（朴素的模式匹配）
### 算法描述
> 算法由Brute和Force提出，所以叫做BF算法

假定目标串的长度为n，模式串的长度为m
+ 从目标串的第0个位置开始遍历匹配，直到目标串的n-m+1
+ 在匹配过程中如果匹配成功就返回索引位置，并终止执行

> 时间复杂度最坏情况下的时间复杂度为O((n-m+1)*m)  

注：BF算法为回溯算法
## RK算法
### 算法描述
> 算法由Rabin和Karp提出，所以叫RK算法

假定目标串的长度为n，模式串的长度为m
+ 计算目标串中每个长度为m的子串的哈希值（时间复杂度为O(n-m+1)，当n远大于m时，时间复杂度为O(n)）
    + 哈希算法的设计：将a-z的26个字母使用26进制编码，计算出每个子串的26进制数，转换为十进制，即为hash值
    + 哈希算法的优化：将26的每个幂次的值存储到字典表中，字典表的下标即为幂
+ 从目标串的第0个位置开始使用hash值遍历匹配，直到目标串的n-m+1（时间复杂度为O(n-m+1)，当n远大于m时，时间复杂度为O(n)）
+ 在匹配过程中如果匹配成功就返回索引位置，并终止执行
> 算法复杂度为O(n)
## BM算法（Boyer-Moore算法）
### 算法描述
> 使用坏字符规则和好后缀规则，对字符串匹配过程进行优化，在不回溯的情况下，最大化右滑

假定目标串的长度为n，模式串的长度为m
+ 模式串的最左端跟目标串的对应位置对齐，从模式串的最右端开始依次匹配，如果发现坏字符（目标串中的字符），停止处理（此时模式串的下标为s）
+ 坏字符规则
    + 如果坏字符在模式串中存在（设索引值为i）,那么将模式串右滑s-i个元素
        + s-i>0，可以右滑（一般在使用的时候，也要借助好后缀）
        + s-i<0，不不可以右滑，需要借助好后缀
    + 如果坏字符在模式串中不存在，将模式串右滑s+1个元素
+ 好后缀规则
    > s下标处的字符为坏字符，那么目标串中从s到m-1的m-1-s个字符为好后缀（设好后缀为{u}）
    + 使用好后缀子字符串，在模式串中查找，是否有跟{u}相匹配的{u*}
    + 如果有{u*}存在，将目标字符右滑到与主串中{u}对齐的位置
    + 如果没有{u*}存在
        + 需要找到{u}中后缀子串（abc的后缀子串为c，bc）和其在模式串中前缀子串（abc的前缀子串为a，ab）匹配
            
+ 出现坏字符时好后缀和坏字符两种规则的选择
    + 使用坏字符查找模式串，是否在模式串中存在，不存在可以直接将模式串后滑到好后缀的下一个字符，否则，记录下坏字符在模式串的索引x并继续下面的步骤
    + 使用好后缀规则查找模式串中的可匹配前缀，如果不存在可以直接将模式串后滑到好后缀的下一个字符，否则，记录下可匹配前缀的最后字符的索引y
    + 比较x，y的大小，取max(x,y)作为右滑位数