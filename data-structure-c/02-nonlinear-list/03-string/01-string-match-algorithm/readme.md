# 字符串匹配
## BF算法（朴素的模式匹配）
### 算法描述
> 算法由Brute和Force提出，所以叫做BF算法

假定目标串的长度为n，模式串的长度为m
+ 从目标串的第0个位置开始遍历匹配，直到目标串的n-m+1
+ 在匹配过程中如果匹配成功就返回索引位置，并终止执行

> 时间复杂度最坏情况下的时间复杂度为O((n-m+1)*m)  

注：BF算法为回溯算法
## RK算法
### 算法描述
> 算法由Rabin和Karp提出，所以叫RK算法

假定目标串的长度为n，模式串的长度为m
+ 计算目标串中每个长度为m的子串的哈希值（时间复杂度为O(n-m+1)，当n远大于m时，时间复杂度为O(n)）
    + 哈希算法的设计：将a-z的26个字母使用26进制编码，计算出每个子串的26进制数，转换为十进制，即为hash值
    + 哈希算法的优化：将26的每个幂次的值存储到字典表中，字典表的下标即为幂
+ 从目标串的第0个位置开始使用hash值遍历匹配，直到目标串的n-m+1（时间复杂度为O(n-m+1)，当n远大于m时，时间复杂度为O(n)）
+ 在匹配过程中如果匹配成功就返回索引位置，并终止执行
> 算法复杂度为O(n)
## BM算法（Boyer-Moore算法）
### 算法描述
> 使用坏字符规则和好后缀规则，对字符串匹配过程进行优化，在不回溯的情况下，最大化右滑  

在用于查找子字符串的算法当中，BM（Boyer-Moore）算法是目前被认为最高效的字符串搜索算法，它由Bob Boyer和J Strother Moore设计于1977年。
 一般情况下，比KMP算法快3-5倍。该算法常用于文本编辑器中的搜索匹配功能，比如大家所熟知的GNU grep命令使用的就是该算法，
 这也是GNU grep比BSD grep快的一个重要原因

假定目标串的长度为n，模式串的长度为m
+ 模式串的最左端跟目标串的对应位置对齐，从模式串的最右端开始依次匹配，如果发现坏字符（目标串中的字符），停止处理（此时模式串的下标为s）
+ 坏字符规则
    + 如果坏字符在模式串中存在（设索引值为i）,那么将模式串右滑s-i个元素
        + s-i>0，可以右滑（一般在使用的时候，也要借助好后缀）
        + s-i<0，不不可以右滑，需要借助好后缀
    + 如果坏字符在模式串中不存在，将模式串右滑s+1个元素
+ 好后缀规则
    > s下标处的字符为坏字符，那么目标串中从s到m-1的m-1-s个字符为好后缀（设好后缀为{u}）
    + 使用好后缀子字符串，在模式串中查找，是否有跟{u}相匹配的{u*}
    + 如果有{u*}存在，将目标字符右滑到与主串中{u}对齐的位置
    + 如果没有{u*}存在
        + 需要找到{u}中后缀子串（abc的后缀子串为c，bc）和其在模式串中前缀子串（abc的前缀子串为a，ab）匹配
            
+ 出现坏字符时好后缀和坏字符两种规则的选择
    + 使用坏字符查找模式串，是否在模式串中存在，不存在可以直接将模式串后滑到好后缀的下一个字符，否则，记录下坏字符在模式串的索引x并继续下面的步骤
    + 使用好后缀规则查找模式串中的可匹配前缀，如果不存在可以直接将模式串后滑到好后缀的下一个字符，否则，记录下可匹配前缀的最后字符的索引y
    + 比较x，y的大小，取max(x,y)作为右滑位数
    
    
## KMP算法
### 算法描述
> 

假定目标串的长度为n，模式串的长度为m
+ 生成next函数
    + 每一个前缀子串都有可能是好前缀子串
    + 找到每一个前缀子串中，最长可匹配后缀子串对应的最长可匹配前缀子串的末尾索引，记录到next函数（失效函数failure function）
        + 如果后缀子串和前缀子串的下个坐标的字符不等，可以继续找次长后缀子串对应的次长前缀子串的下个坐标位置，进行字符匹配
+ 从左往右开始匹配，遇到坏字符后（此时主串索引位置设为i），寻找好前缀的最长可匹配后缀对应的最长可匹配前缀的下标位置k
    + 如果k存在，滑动到k与i对齐
    + 如果k不存在，查找好后缀次长可匹配前缀的下标位置k
+ 继续比较后面的字符，直到完全匹配或者匹配到目标串的末尾没有找到